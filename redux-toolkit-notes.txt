https://github.com/christofferberg/react-redux-toolkit-example

https://react-redux-toolkit-example.now.sh/sign-in

https://github.com/christofferberg/react-redux-toolkit-example

https://dev.to/vcapretz/writing-modern-redux-in-2020-the-powerful-createslice-1i5m

https://stackoverflow.com/questions/60316251/how-to-use-redux-thunk-with-redux-toolkits-createslice

---------------------------------------------------------------------------------------------------------

Redux Toolkit has a configureStore() function that wraps createStore()

---------------------------------------------------------------------------------------------------------

https://redux-starter-kit.js.org/tutorials/basic-tutorial

createAction
// Or, use `createAction` to generate the action creator:
const incrementNew = createAction('INCREMENT')

console.log(incrementNew())
// {type: "INCREMENT"}


---------------------------------------------------------------------------------------------------------
createSlice


const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: state => state + 1,
    decrement: state => state - 1
  }
})

const store = configureStore({
  reducer: counterSlice.reducer
})

document.getElementById('increment').addEventListener('click', () => {
  store.dispatch(counterSlice.actions.increment())
})


const { actions, reducer } = counterSlice
const { increment, decrement } = actions


createSlice combines the actions and reducer

---------------------------------------------------------------------------------------------------------
configureStore
configureStore This will automatically set up the Redux DevTools Extension for us.

createSlice function allows us to consolidate that logic in one place.

createSlice uses createReducer and createAction internally,
so in most apps, you won't need to use them yourself - createSlice is all you need.

---------------------------------------------------------------------------------------------------------




We could replace those using RTK's createReducer and createAction functions. However,
the RTK createSlice function allows us to consolidate that logic in one place.

---------------------------------------------------------------------------------------------------------

js object is state of redux,
it will call combineReducers


import { createSlice } from '@reduxjs/toolkit'

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo(state, action) {
      const { id, text } = action.payload
      state.push({ id, text, completed: false })
    },
    toggleTodo(state, action) {
      const todo = state.find(todo => todo.id === action.payload)
      if (todo) {
        todo.completed = !todo.completed
      }
    }
  }
})

export const { addTodo, toggleTodo } = todosSlice.actions

export default todosSlice.reducer

createSlice Options#

createSlice takes an options object as its argument, with these options:

name: a string that is used as the prefix for generated action types

initialState: the initial state value for the reducer

reducers: an object, where the keys will become action type strings,
and the functions are reducers that will be run when that action type is dispatched.
(These are sometimes referred to as "case reducers", because they're similar to a case in a switch statement)

---------------------------------------------------------------------------------------------------------

https://javascript.info/optional-chaining

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining

console.log(adventurer?.sd || 'hiii');

https://stackoverflow.com/a/59423268/3882241
---------------------------------------------------------------------------------------------------------

ADD_TODO === 'todos/addTodo'

'todos/addTodo' -> todos is name of the createSlice, addTodo is reducers object one of the key

----------------------------------------------------------------------

useEffect(() => {
    async function fetchEverything() {
      async function fetchIssues() {
        const issuesResult = await getIssues(org, repo, page)
        setIssues(issuesResult)
      }
    fetchEverything()
  }, [org, repo, page]);


we can't declare the useEffect callback itself as async.
React expects that the return value from a useEffect callback will be a cleanup function.
Since all async functions return a Promise automatically, React would see that Promise instead,
and that would prevent React from actually cleaning up correctly.

----------------------------------------------------------------------

Thinking in Thunks

The Redux core (ie, createStore) is completely synchronous.
When you call store.dispatch(), the store runs the root reducer, saves the return value, runs the subscriber callbacks,
and returns, with no pause.

By default, any asynchronicity has to happen outside of the store.


Redux middleware

if you want to have async logic interact with the store by
dispatching or checking the current store state?
That's where Redux middleware come in.

----------------------------------------------------------------------

The word "thunk" means

In computer programming, a thunk is a subroutine used to inject an additional calculation into another subroutine.
Thunks are primarily used to delay a calculation until its result is needed.

The word "thunk" means "a function that delays a calculation until later".

----------------------------------------------------------------------

However, Redux Toolkit does not currently provide any special functions or syntax for writing thunk functions. In particular,
they cannot be defined as part of a createSlice() call. You have to write them separate from the reducer logic.

----------------------------------------------------------------------

https://www.digitalocean.com/community/tutorials/redux-redux-thunk

getState

On top of receiving the dispatch method from the state,
the function returned by an asynchronous action creator with Redux Thunk
also receives the storeâ€™s getState method, so that current store values can be read:

export const addTodo = ({ title, userId }) => {
  return (dispatch, getState) => {
    dispatch(addTodoStarted());

    console.log('current state:', getState());

    // ...
  };
};


export const addTodo = ({ title, userId }) => {
  return (dispatch, getState) => {
    const { todos } = getState();

    if (todos.length >= 4) return;

    dispatch(addTodoStarted());

    // ...
  };
};

Using getState can be really useful to react differently depending on the current state.
For example, if we want to limit our app to only 4 todo items at a time,
we could return from the function if the state already contains the maximum amount of todo items:

----------------------------------------------------------------------

https://www.freecodecamp.org/news/redux-thunk-explained-with-examples/

Redux Thunk is middleware that allows you to return functions,
rather than just actions, within Redux.
This allows for delayed actions, including working with promises.


----------------------------------------------------------------------

Ducks pattern

reRUX last 3 characters is the name of Ducks pattern

normal redux we commonly use 3 files

actions,
actionTypes (actionCreators),
reducers

in Ducks pattern we use single file to handle all these process

----------------------------------------------------------------------